一般的には、新機能の開発はマスターで行われるべきです。

バグの修正は、新規の API を取り入れたり、既存の API を壊してはいけません、また機能フラグも不要です。

新機能は新 API を導入することができ、機能フラグが必要です。新機能はリリースやベータブランチに対して適用してはいけません、なぜならセマンティックバージョニングでは新機能はマイナーバージョンの更新をする必要があるからです。

セキュリティの問題が既存のAPIを壊す必要がない限り、セキュリティ修正プログラムは新たなAPIを導入してはいけません。そのような修正は最小限に限られるべきです。

### Bug Fixes

#### 緊急のバグ修正

緊急のバグ修正は、既存のリリースブランチに対して適用されるものです。可能であれば、マスターに対して行われ、[BUGFIX release] がつけられるべきです。

#### ベータ版バグ修正

ベータ版バグ修正はベータ版に適用されるべき、バグ修正です。可能であれば、マスターで作成され、 [BUGFIX beta] のタグがつけられるべきです。

#### セキュリティ修正プログラム

セキュリティ修正はベータブランチ、カレントブランチと前のタグに対して行われるべきで、可能であれば、 [SECURITY] とタグを付けマスターにも適用するべきです。

### 機能:

新機能は、必ず、機能フラグでラップする必要があります。新機能のテストもまた、機能フラグでラップする必要があります。

ビルドツールが、機能フラグほ処理するため、機能フラグのフォーマットは正確に次の形式にする必要があります。 ファンクションは、ファンクションはスコープを変えて、早期にreturnしてしまわないように、私たちはブロックではなく、コンディショナルを利用しています。

```js
if (Ember.FEATURES.isEnabled("feature")) {
  // implementation
}
```

テストは必ず全ての機能を有効にして、行われますので、現状のテストに対して、機能テストが引き渡されていることを確認してください。

#### コミット

特定の機能に対するコミットは、次のようなプレフィックスを含める必要があります。 [FEATURE htmlbars] こうすることで、この先、特定の機能を素早く特定することことができるようになります。 機能は決して、ベータやリリースブランチに対しては適用されません。 ベータやリリースブランチが切られたら、そのブランチが持つ機能の全てをすでに含んでいるということになります。

 もし機能がベータやリリースにたどり着いて、もしマスターにその機能のバグを修正するコミットをしたら、上記のようにコミットを行ってください。

#### 機能ネーミング規則

```config/environment.js Ember.FEATURES['<packagename>-<feature>'] // if package specific Ember.FEATURES['container-factory-injections'] Ember.FEATURES['htmlbars']

    <br />### ビルド
    
    カナリーのビルドは、マスターに基づいており、オリジナルのソースを囲った、全ての機能を備えています。 これは、カナリービルドのユーザーはEmberアプリケーションを作成する前に、希望する機能を有効化することができます。
    
    ```config/environment.js
    module.exports = function(environment) {
      var ENV = {
        EmberENV: {
          FEATURES: {
            htmlbars: true
          }
        },
      }
    }
    

### `features.json`

リポジトリのルートにはfeatures.jsonがあり、ベータやリリースをビルドする際に機能のを有効化することができます。

このファイルはブランチを切る際に作成されて、その後、機能の追加は行われませんが削除される可能があります。

```js
{
  "htmlbars": true
}
```

ビルドプロセスはリストにない機能を取り除き、リストから該当の機能の条件を取り除きます。

### トラヴィスのテスト

新規のPRについて

  1. Travis-ciはマスターに対して、全ての機能フラグを有効にしてテストを行います。
  2. もしコミットに [BUGFIX beta] タグが付けられていたら、 Travis はタグが付けられたコミットを選択して、ベータブランチでのテストにも適応します。 もしコミットが正常に適用されない、あるいは失敗する場合は、テストは失敗で終わります。
  3. コミットが [BUGFIX release] とタグ付けされていたら、Travis はタグが付けられたコミットを選択して、リリースブランチでのテストにも適応します。 もしコミットが正常に適用されない、あるいは失敗する場合は、テストは失敗で終わります。

マスターに対する新規コミット

  1. Travis は上記に示したように、テストを行います。
  2. もしビルドに成功すれば、Travis はコミットを選択して該当するブランチに含めます。

アイデアは、新規のコミットは、PRとしてなされることで、Travis が適切なブランチにコミットが正しく適応されていることを確約するということです。

### Go/No-Go プロセス

6 週間ごとにコア チームは、次のプロセスを行います。

#### ベータブランチ

ベーラブランチに残った機能は準備が整っているか、厳密に精査されます。機能がもし準備が不十分ならfeatures.jsonから取り除かれます。

これが完了すると、ベータブランチはタグ付けされ、リリースにマージされます。

#### マスター ブランチ

マスターランチに残った機能は準備が整っているか、厳密に精査されます。 この段階で機能が「準備完了」とされるのは、文字通り全く障害がないという意味になります。 準備が整っていないと判断された機能はベータブランチに留まり、準備が整えられます。

この工程は６週おきに行われるので、新規機能が「準備が整っている」とされる機会はすぐにまた来ます。

この工程が完了したら、マスターブランチはベータブランチにマージされます。`features.json`ファイルに準備ができた機能が追加されます。

### ベータリリース

ベータブランチに残っている機能に対して、準備が整った/整っていないという工程を毎週行います。準備が整っていないとされた機能があれば、features.jsonから取り除かれます。

この工程が完了したなら、ベータリリースはタグ付けされ、プッシュされます。